# ===========================================================================================
# CI/CD Pipeline for Order Management Microservices
# ===========================================================================================
# This workflow automates testing and building of all Spring Boot microservices
# It runs on every push to the main branch to ensure code quality and build integrity
# ===========================================================================================

name: CI Pipeline

# Trigger Configuration
# WHY: Automatically run tests and builds when code is pushed to main branch
# This ensures that the main branch always contains working, tested code
on:
  push:
    branches:
      - main

jobs:
  # ===========================================================================================
  # JOB 1: TEST
  # ===========================================================================================
  # WHY: Run tests for all microservices to catch bugs early before building
  # Tests are run in parallel using a matrix strategy to speed up the pipeline
  # ===========================================================================================
  test:
    name: Test ${{ matrix.service }}
    runs-on: ubuntu-latest

    # Matrix Strategy
    # WHY: Allows us to run the same test steps for all three services in parallel
    # This reduces total pipeline execution time from ~15 minutes to ~5 minutes
    strategy:
      # WHY: fail-fast: false ensures all services are tested even if one fails
      # This gives us complete feedback about all services in a single run
      fail-fast: false
      matrix:
        service:
          - order-service
          - user-service
          - notification-service

    steps:
      # Step 1: Checkout Code
      # WHY: Downloads the repository code so we can build and test it
      # uses v3 for stability and security updates
      - name: Checkout code
        uses: actions/checkout@v3

      # Step 2: Setup Java Development Kit
      # WHY: Spring Boot 4.x requires Java 21 to compile and run
      # Temurin is the open-source JDK distribution (formerly AdoptOpenJDK)
      - name: Set up JDK 21
        uses: actions/setup-java@v3
        with:
          java-version: '21'
          distribution: 'temurin'

      # Step 3: Cache Maven Dependencies
      # WHY: Maven downloads many dependencies (JARs) that don't change often
      # Caching them speeds up subsequent builds from ~5 minutes to ~30 seconds
      # The cache key is based on pom.xml files - if they change, cache is invalidated
      - name: Cache Maven packages
        uses: actions/cache@v3
        with:
          path: ~/.m2/repository
          key: ${{ runner.os }}-maven-${{ hashFiles('**/pom.xml') }}
          # WHY: restore-keys provides a fallback if exact match isn't found
          # This allows partial cache hits to still speed up the build
          restore-keys: |
            ${{ runner.os }}-maven-

      # Step 4: Run Tests
      # WHY: Execute JUnit tests to verify code correctness
      # chmod +x ensures the Maven wrapper script has execute permissions
      # ./mvnw test runs all tests without creating a JAR file (faster than package)
      - name: Run tests for ${{ matrix.service }}
        run: |
          cd ${{ matrix.service }}
          chmod +x mvnw
          ./mvnw test

  # ===========================================================================================
  # JOB 2: BUILD
  # ===========================================================================================
  # WHY: After tests pass, build the JAR files for each microservice
  # The 'needs: test' ensures builds only run if all tests pass (quality gate)
  # ===========================================================================================
  build:
    name: Build ${{ matrix.service }}
    runs-on: ubuntu-latest

    # Dependency Declaration
    # WHY: Ensures builds only happen after all tests pass
    # This prevents wasting resources building broken code
    needs: test

    # Matrix Strategy
    # WHY: Build all three services in parallel for faster pipeline execution
    strategy:
      fail-fast: false
      matrix:
        service:
          - order-service
          - user-service
          - notification-service

    steps:
      # Step 1: Checkout Code
      # WHY: Each job runs in a fresh environment, so we need to checkout again
      - name: Checkout code
        uses: actions/checkout@v3

      # Step 2: Setup Java Development Kit
      # WHY: Required to compile Java code and create executable JAR files
      - name: Set up JDK 21
        uses: actions/setup-java@v3
        with:
          java-version: '21'
          distribution: 'temurin'

      # Step 3: Cache Maven Dependencies
      # WHY: Reuse the same dependencies cached during the test job
      # This significantly speeds up the build process
      - name: Cache Maven packages
        uses: actions/cache@v3
        with:
          path: ~/.m2/repository
          key: ${{ runner.os }}-maven-${{ hashFiles('**/pom.xml') }}
          restore-keys: |
            ${{ runner.os }}-maven-

      # Step 4: Build JAR File
      # WHY: Create the executable JAR file that can be deployed
      # 'clean' removes old build artifacts to ensure a fresh build
      # 'package' compiles code, runs tests, and creates the JAR
      # '-DskipTests' skips tests since we already ran them in the test job
      - name: Build ${{ matrix.service }}
        run: |
          cd ${{ matrix.service }}
          chmod +x mvnw
          ./mvnw clean package -DskipTests

      # Step 5: Upload Build Artifacts (Optional - commented out for Week 1)
      # WHY: This would save the JAR files so they can be downloaded or used in deployment
      # Uncomment this in Week 2 when adding Docker image building
      # - name: Upload JAR artifact
      #   uses: actions/upload-artifact@v3
      #   with:
      #     name: ${{ matrix.service }}-jar
      #     path: ${{ matrix.service }}/target/*.jar
